- https://juejin.cn/post/6981588276356317214#heading-4

### 标记清除法

流程
 - 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0
 - 然后从各个根对象开始遍历，把不是垃圾的节点改成1
 - 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间
 - 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收

缺点

 - 清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 内存碎片
 - 这就牵扯出了内存分配的问题
 - 三种分配策略
    - First-fit，找到大于等于 size 的块立即返回
    - Best-fit，遍历整个空闲列表，返回大于等于 size 的最小分块
    - Worst-fit，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 size 大小，并将该部分返回
    - 这三种策略里面 Worst-fit 的空间利用率看起来是最合理，但实际上切分之后会造成更多的小块，形成内存碎片，所以不推荐使用，对于 First-fit 和 Best-fit 来说，考虑到分配的速度和效率 First-fit 是更为明智的选择

标记整理（Mark-Compact）算法

 - 只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存

### 引用计数算法

 - 它把 **对象是否不再需要** 简化定义为 **对象有没有其他对象引用到它**，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，目前很少使用这种算法了，因为它的问题很多。

优点

 - 引用计数算法的优点我们对比标记清除来看就会清晰很多，首先引用计数在引用值为 0 时，也就是在变成垃圾的那一刻就会被回收，所以它可以立即回收垃圾

缺点

 - 循环引用时，引用计数则不会被清理，因为它们的引用数量不会变成 0
 - 首先它需要一个计数器，而此计数器需要占很大的位置

### V8对GC的优化

- https://juejin.cn/post/6981588276356317214#heading-6
- 分代式垃圾回收
  - 分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，可以说此机制的出现很大程度提高了垃圾回收机制的效率
- 并行回收
  - 进行垃圾回收时就会阻塞 JavaScript 脚本的执行‘
  - 因此 V8 团队引入了并行回收机制
  - 增量标记


